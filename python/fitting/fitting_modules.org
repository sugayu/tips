#+title: *Fittingに使われるPythonモジュールの比較*
#+AUTHOR: sugayu
#+LATEX_CLASS: jsarticle2
#+OPTIONS: toc:nil

* 導入
データのフィッティングに使用可能なPythonモジュールは数多くある。
これらを比較することで、
(1) 使用感の違いを見る、
(2) 使い方をメモする、
(3) 最尤値や誤差が正しく求まるか調べる
ことを目的とする。

* 比較対象のPythonモジュール
** NumPy
~NumPy~ は ~polynomial~ という多項式を扱うモジュールを提供している。
この中で ~fit()~ というメソッドが提供されており、これを使ってモデルの最適化が可能である。
内部で ~numpy.linalg.lstsq~ という最適化関数を使っている。
物理学でよく使われる名前のついた多くの多項式を扱えるが、ガウス関数などは無いので輝線のフィッティングには使えない(と思う)。
- [[https://numpy.org/doc/stable/reference/routines.polynomials-package.html#module-numpy.polynomial][numpy.polynomial — NumPy v2.2 Manual]]
- [[https://numpy.org/doc/stable/reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq][numpy.linalg.lstsq — NumPy v2.2 Manual]]

** Scipy
~SciPy~ は ~optimize~ という最適化のためのモジュールを提供している。
この中で ~curve_fit()~ という関数は非線形最小二乗法によりモデルの最適化を行う。
- [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.curve_fit.html][curve_fit — SciPy v1.15.2 Manual]]
2変数の間の線形回帰は ~linregress()~ という関数でも与えられており、こちらを使えば関数を指定してやる必要がない。
- [[https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.linregress.html#scipy.stats.linregress][linregress — SciPy v1.15.2 Manual]]

** Astropy
天文解析パッケージ ~Astropy~ は ~modeling~ というモジュールを提供している。
天文関係で使うと思われるモデルやフィッティングの関数が網羅されているので、
使いたいモデルが実装されていないか確認する価値がある。
- [[https://docs.astropy.org/en/stable/modeling/][Models and Fitting (astropy.modeling) — Astropy v7.0.1]]
~modeling.models~ モジュールが提供するクラスを使って統計モデルを構築し、
~modeling.fitting~ モジュールが提供するクラスを使ってモデルをデータに当て嵌める。
- [[https://docs.astropy.org/en/stable/modeling/models.html][Models — Astropy v7.0.1]]
- [[https://docs.astropy.org/en/stable/modeling/fitting.html][Fitting Models to Data — Astropy v7.0.1]]

** specutils
天体スペクトルを扱うパッケージ ~specutils~ は輝線フィッティングを含めたスペクトル解析のためのモジュールを提供する。
フィッティングの際には内部で ~Astropy.modeling~ モジュールが呼ばれている。
ユーザーの輝線フィッティングを助けるパッケージとも言える。
- [[https://specutils.readthedocs.io/en/stable/fitting.html][Line/Spectrum Fitting — specutils v1.19.1.dev0+g746a5d4.d20241105]]

** MPFIT
~MPFIT~ は古くから天文学で使われているフィッティングパッケージ。
元々はFortranで書かれた ~MINPACK-1~ というパッケージの中のフィッティングコードを
Craig MarkwardtさんがIDLで書き直した。
それをMark RiversさんがPythonで書き直し、Sergey Koposovさんが ~numpy~ で実装し直した後にPython3で動くようにした。
Levenberg-Marquardt法を使っているので効率良く最小二乗問題を解けるのが売りだった。
- [[https://eispac.readthedocs.io/en/stable/guide/07-mpfit_docs.html][MPFIT Documentation — eispac 0.1.dev108+gdfa97b1 documentation]]
- [[https://github.com/segasai/astrolibpy/blob/master/mpfit/mpfit.py][astrolibpy/mpfit/mpfit.py at master · segasai/astrolibpy · GitHub]]

** LMFIT
~LMFIT~ は非線形最小二乗法を解くためのパッケージ。
~scipy.optimize~ モジュールから着想を得て、フィッティングのための便利な機能を多数導入している。
- [[https://lmfit.github.io/lmfit-py/index.html][Non-Linear Least-Squares Minimization and Curve-Fitting for Python — Non-Linear Least-Squares Minimization and Curve-Fitting for Python]]

* 理想的な線形データのフィッティング結果
** データ作成
- 平均: 100.0
- 標準偏差: 10.0
- 標本の大きさ: 30
- 直線: \(y = 2.0 (x - 100.0) + 220.0\)
#+begin_src ipython :session :ipyfile ./obipy-resources/data.png :exports both :async t :results raw drawer :eval never-export
  import numpy as np
  from numpy.random import default_rng
  from sugayutils.figure import makefig

  rng = default_rng(222)

  size = 30
  sigma0 = 10.0
  sigma = rng.standard_normal(size) * sigma0
  x0 = 100.0
  x = rng.normal(x0, 10, size=size)

  a, b = 2.0, 220.0
  y0 = a * (x - x0) + b
  y = y0 + sigma

  fig = makefig(figsize=['small', 1.0])
  ax = fig.add_subplot(1, 1, 1)
  _ = ax.scatter(x, y)
#+end_src

#+RESULTS:
:results:
# Out[3]:
[[file:./obipy-resources/data.png]]
:end:

** 解析解
一次方程式の場合は解析解が得られている。
係数の最尤推定値は
\begin{align}
\label{eq:1}
  a &= \frac{N\sum x_i y_i - \sum x_i \sum y_i}{N\sum x_i^2 - (\sum x_i)^2} \\
  b &= \frac{\sum x_i^2 \sum y_i - \sum x_i \sum x_i y_i}{N\sum x_i^2 - (\sum x_i)^2}
\end{align}
であり、その誤差は
\begin{align}
\label{eq:2}
  \sigma_\text{a} & = \sigma \sqrt{\frac{N}{N\sum x_i^2 - (\sum x_i)^2}} \\
  \sigma_\text{b} & = \sigma \sqrt{\frac{\sum x_i^2}{N\sum x_i^2 - (\sum x_i)^2}} \\
\end{align}
と表せる。
- [[http://www.cc.u-ryukyu.ac.jp/~fukami/p0.pdf][物理実験III データ処理 (琉球大学深水研究室)]]

以上より最尤推定値を求める。
#+begin_src ipython :session :exports both :async t :results raw drawer :eval never-export
  _x = x - x0
  denom = (size * np.sum(_x**2) - np.sum(_x) ** 2)
  sol_analytic = {
      'a': (size * np.sum(_x * y) - np.sum(_x) * np.sum(y)) / denom,
      'b': (np.sum(_x**2) * np.sum(y) - np.sum(_x) * np.sum(_x * y)) / denom,
      's_a': sigma0 * np.sqrt(size / denom),
      's_b': sigma0 * np.sqrt(np.sum(_x ** 2) / denom)
  }
  sol_analytic
#+end_src

#+RESULTS:
:results:
# Out[4]:
#+BEGIN_EXAMPLE
  {'a': 1.8419873744634017,
  'b': 221.09327400439,
  's_a': 0.18305375486749972,
  's_b': 1.8375169284378194}
#+END_EXAMPLE
:end:

1sigma誤差の範囲に真値が収まっている。

** Numpy
~Polynomial.fit()~ を使ったフィッティング手法を示す。
デフォルトの返り値は ~Polynomial~ インスタンスである。
~full=True~ のキーワード引数を与えるとタプルを出力し、2番目の要素にフィッティングの情報が含まれる。
- [[https://numpy.org/doc/stable/reference/generated/numpy.polynomial.polynomial.Polynomial.fit.html#numpy.polynomial.polynomial.Polynomial.fit][numpy.polynomial.polynomial.Polynomial.fit — NumPy v2.2 Manual]]
#+begin_src ipython :session :exports both :async t :results raw drawer :eval never-export
  from numpy.polynomial import Polynomial

  _x = x - x0
  p, status = Polynomial.fit(_x, y, 1, w=1 / sigma, full=True)
  p = p.convert()

  sol_numpy_poly = {'a': p.coef[1], 'b': p.coef[0], 's_a': 0, 's_b': 0}
  sol_numpy_poly
#+end_src

#+RESULTS:
:results:
# Out[6]:
: {'a': 2.0169555112890785, 'b': 219.8701393926761, 's_a': 0, 's_b': 0}
:end:

なぜか解析解よりも真値に近い値を出しているが、誤差を出力してくれないようである。
なお、 ~Polynomial.fit()~ は ~Polynomial~ クラスのクラスメソッドである。

** Scipy


** Astropy
** MPFIT
** LMFIT
** まとめ

* 理想的な輝線データのフィッティング結果
** データ作成
** Numpy
** Scipy
** Astropy
** specutils
** MPFIT
** LMFIT
** まとめ
