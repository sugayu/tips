#+title: *Elisp---Emacs LISP*
#+AUTHOR: sugayu

* 基本構文

** 条件分岐
- [[info:elisp#Conditionals][elisp#Conditionals]]

単純な条件分岐には ~if~ が使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (if t
      (message "Print this if True")
    (message "Print this if false"))
#+end_src

#+RESULTS:
:results:
Print this if True
:end:

~t~ のときのみの実行は ~when~ が使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (when t
    (message "Print this when True.")
    (message "Recieve sequential commands."))
#+end_src

#+RESULTS:
:results:
Recieve sequential commands.
:end:


複数の条件分岐には ~cond~ が使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (cond ((eq "a" "not a") "False")
        (t "True"))
#+end_src

#+RESULTS:
:results:
True
:end:

パターンマッチには ~pcase~ が使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (pcase "answer"
    (`answer 'ans)
    ((pred stringp) 'string)
    (_ 'fallback))
#+end_src

#+RESULTS:
:results:
string
:end:

- [[https://qiita.com/t-suwa/items/20a4ebf37b0a57ff88b2][Emacs：パターンマッチでスクレイピング #Emacs - Qiita]]

** ループ
Lispでは基本的にループは使わずに、 ~map~ 系の関数を使うはず。それでも一応ループも用意されている。

リストに対して同じ操作を繰り返すときには ~dolist~ が使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (dolist (buffer (buffer-list))
    (kill-buffer (buffer-name buffer)))
#+end_src

** 判定
- derived-mode-p :: 現在のbufferのmode判定 ~(derived-mode-p 'org-mode)~ 。返り値はmode名。
- file-exists-p :: 文字列のファイル名が存在するか。

* ファイルとバッファ
- [[info:elisp#Visiting Files][elisp#Visiting Files]]
- [[info:elisp#Buffer File Name][elisp#Buffer File Name]]
ファイルに対して、バッファは一時的な編集の場であり、
一般に言う「ファイルを開く」はEmacsではファイル内容をバッファに読み込む、と言う。

** 便利な変数・関数
ファイル名とバッファ名は異なるので、与える引数の間違いに注意する。
- v ~buffer-file-name~ :: 現在のバッファの名前
- f ~buffer-name~ :: バッファ自体は特殊な名前構造を持っている。バッファの名前を文字列で返す。
- f ~file-name-directory~ :: 与えたファイルが存在するディレクトリを返す。

** 作業するカレントバッファを設定する
一時的に別のバッファを操作する場合、 ~set-buffer~ でそのバッファを設定する。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (save-current-buffer
    (set-buffer (get-buffer-create "new-buffer")))
#+end_src

** ファイルを開いているバッファを得る
以下の二つの関数を使うと目的のバッファが見つかると考えられる。
- f ~get-file-buffer~ :: ファイルをvisitしているバッファを返す
- f ~find-buffer-visiting~ :: ファイルをvisitしているかもしれないバッファを返す
バッファが見つからない場合、これらは ~nil~ を返す。

例はorg-macs.elより:
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (defun org-find-base-buffer-visiting (file)
    "Like `find-buffer-visiting' but always return the base buffer.
  FILE is the file name passed to `find-buffer-visiting'."
    (let ((buf (or (get-file-buffer file)
                   (find-buffer-visiting file))))
      (org-base-buffer buf)))
#+end_src

** 新しいファイルを開く
- f ~find-file-noselect~ :: ファイルをバッファに読み込み、バッファを返す。それを現在のバッファにしたり表示したりはしない。

** ファイルに書き込む
新規や既存のファイルを開いて書き込むだけなら、 ~with-temp-file~ を使う。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (with-temp-file "filename"
    (insert "#+title: This is title\n"))
#+end_src

~find-file~ や ~find-file-noselect~ はファイルを開いたあとに、
メジャーモードの指定やhookの実行など非対話的モードでは必要ない操作や副作用が多い。
- [[https://emacs.stackexchange.com/questions/2868/whats-wrong-with-find-file-noselect][What's wrong with `find-file-noselect`? - Emacs Stack Exchange]]

** バッファをウィンドウに表示する
選択したバッファをウィンドウに表示するには ~pop-to-buffer-same-window~ を使う。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (let* ((path (expand-file-name ".emacs.d/init.el" (getenv "HOME")))
         (buffer (or (get-file-buffer path)
                     (find-buffer-visiting path))))
    (when buffer
      (pop-to-buffer-same-window buffer)))
#+end_src

~switch-to-buffer~ もあるが、こちらを使えばいいらしい。知らんけど。
- [[https://emacs.stackexchange.com/questions/27712/switch-to-buffer-vs-pop-to-buffer-same-window][`switch-to-buffer` vs. `pop-to-buffer-same-window` - Emacs Stack Exchange]]
- [[info:elisp#Switching Buffers][elisp#Switching Buffers]]

** ファイルをリストする
~directory-files~ で指定したディレクトリのファイルをリストにすることができる。
オプションは
- FULL :: 絶対パスを返す。
- MATCH :: 正規表現マッチを行う。
- NOSORT :: 並びかえない。あとから自分で並びかえるときに使う。
- COUNT :: 指定した数だけしかファイルを返さない。
例として、実際に作った、現在のディレクトリ上にある
特定の名前を持つファイルリストを作って逆順に並びかえるコマンドを挙げる。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (defun my/directory-journal-files ()
    (reverse
     (sort
      (directory-files (file-name-directory buffer-file-name) nil "20..w...org" t)
      'string-lessp)))
#+end_src

* カーソル移動とマーカー

** バッファ内でカーソルを移動させる
~goto-char~ を使う。
引数には ~POSITION~ を与える。1がバッファの先頭になる。

** バッファの開始点と終了点に移動する
- f ~point-min~ :: バッファ内で許されうる最小の位置を返す。
- f ~point-max~ :: バッファ内で許されうる最大の位置を返す。
おそらく「許されうる」がポイントで、
バッファがnarrowingなどで狭まっていた場合には、狭まった範囲の最小値・最大値を返すと思われる。

以下の式を評価する(~C-x C-e~)とバッファの最後に移動する。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (goto-char (point-max))
#+end_src

* リスト処理
** リスト結合
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (append '(1 2 3) '(3 4 5))
#+end_src

#+RESULTS:
:results:
| 1 | 2 | 3 | 3 | 4 | 5 |
:end:

** リストの要素処理
要素の削除は ~delete~ (破壊的) か ~remove~ (非破壊的)。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (let* ((a '(2 3 4))
         (b '(2 3 4))
         (c (remove 3 b)))
    (delete 3 a)
    (append a '("/") b '("/") c))
#+end_src

#+RESULTS:
:results:
| 2 | 4 | / | 2 | 3 | 4 | / | 2 | 4 |
:end:

** 同一要素に対する処理
重複の無いリストにするには ~delete-dups~ (破壊的) か ~seq-uniq~ (非破壊的) を使う。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (let ((a '(2 3 4 6 6 3 7 2 4))
        (b '(2 3 4 6 6 3 7 2 4)))
    (delete-dups a)
    (seq-uniq b)
    (append a '("/") b))
#+end_src

#+RESULTS:
:results:
| 2 | 3 | 4 | 6 | 7 | / | 2 | 3 | 4 | 6 | 6 | 3 | 7 | 2 | 4 |
:end:

重複している要素をリストから除くには ~seq-difference~ が使える。
引数の順番は、前者のリストから後者に含まれるものを除く、を意味するので注意する。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (let ((a '(2 3 4 6 6 3 7 2 4))
        (b '(2 3 4 6)))
    (seq-difference a b))
#+end_src

#+RESULTS:
:results:
| 7 |
:end:

- 便利な関数は [[file:/usr/local/Cellar/emacs-mac@29/emacs-29.4-mac-10.1/Emacs.app/Contents/Resources/lisp/emacs-lisp/seq.el.gz][seq.el.gz]] に含まれていると思われる。

* 文字列処理
** 検索
文字列内の検索には ~string-match~ が正規表現とともに使える。
#+begin_src emacs-lisp :results raw drawer :eval never-export
  (remove nil
          (mapcar (lambda (buffer)
                    (when (string-match (format-time-string "%Yw...org") (buffer-name buffer))
                      (buffer-name buffer)))
                  (buffer-list)))
#+end_src

#+RESULTS:
:results:
| 2025w40.org | 2025w39.org |
:end:


* Link
- [[info:elisp][elisp]]
